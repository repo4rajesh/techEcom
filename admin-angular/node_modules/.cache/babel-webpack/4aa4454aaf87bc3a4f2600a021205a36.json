{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Effect, ofType } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { map, switchMap } from 'rxjs/operators';\nimport { catchError } from 'rxjs/operators';\nimport * as actions from '../emailtemp-action/emailtemp.action';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"../emailtemp.service\";\nexport class EmailTempEffect {\n  constructor(action$, service) {\n    this.action$ = action$;\n    this.service = service; // NEW EMAIL_TEMP\n\n    this.doAddEmailTemp$ = this.action$.pipe(ofType(actions.ActionTypes.DO_NEW_EMAIL_TEMP_ACTION), map(action => action.payload), switchMap(state => {\n      return this.service.addEmailtemp(state).pipe(switchMap(role => [new actions.DoNewEmailTempSuccessAction(role)]), catchError(error => of(new actions.DoNewEmailTempFailAction(error))));\n    }));\n    this.doUpdateEmailTemp$ = this.action$.pipe(ofType(actions.ActionTypes.DO_UPDATE_EMAIL_TEMP_ACTION), map(action => action.payload), switchMap(state => {\n      return this.service.updateEmailTemp(state).pipe(switchMap(user => {\n        return [new actions.DoUpdateEmailTempSuccessAction(user)];\n      }), catchError(error => of(new actions.DoUpdateEmailTempFailAction(error))));\n    })); // EMAIL TEMP LIST\n\n    this.doemailtemplists$ = this.action$.pipe(ofType(actions.ActionTypes.GET_EMAIL_TEMP_LIST_ACTION), map(action => action.payload), switchMap(state => {\n      return this.service.emailtemplist(state).pipe(switchMap(user => [new actions.DoEmailTemplistSuccessAction(user)]), catchError(error => of(new actions.DoEmailTemplistFailAction(error))));\n    })); // PAGINATION EMAIL_TEMP\n\n    this.doemailtemppagination$ = this.action$.pipe(ofType(actions.ActionTypes.GET_EMAIL_TEMP_COUNT_ACTION), map(action => action.payload), switchMap(state => {\n      return this.service.emailtempPagiantion(state).pipe(switchMap(user => [new actions.DoEmailTempPaginationSuccessAction(user)]), catchError(error => of(new actions.DoEmailTempPaginationFailAction(error))));\n    })); // EMAIL_TEMP DELETE\n\n    this.doEmailtempDelete$ = this.action$.pipe(ofType(actions.ActionTypes.DO_EMAIL_TEMP_DELETE), map(action => action.payload), switchMap(state => {\n      const emailTemplateId = state.emailTemplateId;\n      return this.service.deleteEmailtemp(state, emailTemplateId).pipe(switchMap(user => [new actions.DoEmailTempDeleteSuccessAction(user)]), catchError(error => of(new actions.DoEmailTempDeleteFailAction(error))));\n    }));\n  }\n\n}\n\nEmailTempEffect.ɵfac = function EmailTempEffect_Factory(t) {\n  return new (t || EmailTempEffect)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.EmailTempService));\n};\n\nEmailTempEffect.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: EmailTempEffect,\n  factory: EmailTempEffect.ɵfac\n});\n\n__decorate([Effect()], EmailTempEffect.prototype, \"doAddEmailTemp$\", void 0);\n\n__decorate([Effect()], EmailTempEffect.prototype, \"doUpdateEmailTemp$\", void 0);\n\n__decorate([Effect()], EmailTempEffect.prototype, \"doemailtemplists$\", void 0);\n\n__decorate([Effect()], EmailTempEffect.prototype, \"doemailtemppagination$\", void 0);\n\n__decorate([Effect()], EmailTempEffect.prototype, \"doEmailtempDelete$\", void 0);","map":null,"metadata":{},"sourceType":"module"}