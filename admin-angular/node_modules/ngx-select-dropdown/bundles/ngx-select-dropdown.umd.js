(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-select-dropdown', ['exports', '@angular/core', '@angular/forms', '@angular/common'], factory) :
    (global = global || self, factory(global['ngx-select-dropdown'] = {}, global.ng.core, global.ng.forms, global.ng.common));
}(this, (function (exports, core, forms, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/ngx-select-dropdown.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SelectDropDownService = /** @class */ (function () {
        function SelectDropDownService() {
            // constructor
            this._isOpen = false;
        }
        Object.defineProperty(SelectDropDownService.prototype, "isOpen", {
            get: /**
             * @return {?}
             */
            function () {
                return this._isOpen;
            },
            enumerable: true,
            configurable: true
        });
        SelectDropDownService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: "root",
                    },] }
        ];
        /** @nocollapse */
        SelectDropDownService.ctorParameters = function () { return []; };
        /** @nocollapse */ SelectDropDownService.ɵprov = core.ɵɵdefineInjectable({ factory: function SelectDropDownService_Factory() { return new SelectDropDownService(); }, token: SelectDropDownService, providedIn: "root" });
        return SelectDropDownService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        SelectDropDownService.prototype._isOpen;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/pipes/filter-by.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * filters an array based on searctext
     */
    var FilterByPipe = /** @class */ (function () {
        function FilterByPipe() {
        }
        /**
         * @param {?} array
         * @param {?=} searchText
         * @param {?=} keyName
         * @return {?}
         */
        FilterByPipe.prototype.transform = /**
         * @param {?} array
         * @param {?=} searchText
         * @param {?=} keyName
         * @return {?}
         */
        function (array, searchText, keyName) {
            if (!array || !searchText || !Array.isArray(array)) {
                return array;
            }
            if (typeof array[0] === 'string') {
                return array.filter((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) { return item.toLowerCase().indexOf(searchText.toLowerCase()) > -1; }));
            }
            // filter array, items which match and return true will be
            // kept, false will be filtered out
            if (!keyName) {
                return array.filter((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    for (var key in item) {
                        if (typeof item[key] !== 'object' && item[key].toString().toLowerCase().indexOf(searchText.toLowerCase()) > -1) {
                            return true;
                        }
                    }
                    return false;
                }));
            }
            else {
                return array.filter((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    if (typeof item[keyName] !== 'object' && item[keyName].toString().toLowerCase().indexOf(searchText.toLowerCase()) > -1) {
                        return true;
                    }
                    return false;
                }));
            }
        };
        FilterByPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'filterBy'
                    },] }
        ];
        return FilterByPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/ngx-select-dropdown.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxSelectDropdownComponent = /** @class */ (function () {
        function NgxSelectDropdownComponent(cdref, _elementRef) {
            this.cdref = cdref;
            this._elementRef = _elementRef;
            /**
             * Get the required inputs
             */
            this.options = [];
            /**
             * configuration options
             */
            this.config = {};
            /**
             * Whether multiple selection or single selection allowed
             */
            this.multiple = false;
            /**
             * change event when value changes to provide user to handle things in change event
             */
            this.change = new core.EventEmitter();
            /**
             * The search text change event emitter emitted when user type in the search input
             */
            this.searchChange = new core.EventEmitter();
            /**
             * Event emitted when dropdown is open.
             */
            this.open = new core.EventEmitter();
            /**
             * Event emitted when dropdown is open.
             */
            this.close = new core.EventEmitter();
            /**
             * Toogle the dropdown list
             */
            this.toggleDropdown = false;
            /**
             * Available items for selection
             */
            this.availableItems = [];
            /**
             * Selected Items
             */
            this.selectedItems = [];
            /**
             * Selection text to be Displayed
             */
            this.selectedDisplayText = 'Select';
            /**
             * variable to track if clicked inside or outside of component
             */
            this.clickedInside = false;
            /**
             * variable to track keypress event inside and outsid of component
             */
            this.insideKeyPress = false;
            /**
             * variable to track the focused item whenuser uses arrow keys to select item
             */
            this.focusedItemIndex = null;
            /**
             * element to show not found text when not itmes match the search
             */
            this.showNotFound = false;
            this.onChange = (/**
             * @return {?}
             */
            function () {
                // empty
            });
            this.onTouched = (/**
             * @return {?}
             */
            function () {
                // empty
            });
            this.multiple = false;
        }
        Object.defineProperty(NgxSelectDropdownComponent.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () {
                return this._value;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */
            function (val) {
                this._value = val;
                this.onChange(val);
                this.onTouched();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * click listener for host inside this component i.e
         * if many instances are there, this detects if clicked inside
         * this instance
         */
        /**
         * click listener for host inside this component i.e
         * if many instances are there, this detects if clicked inside
         * this instance
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.clickInsideComponent = /**
         * click listener for host inside this component i.e
         * if many instances are there, this detects if clicked inside
         * this instance
         * @return {?}
         */
        function () {
            this.clickedInside = true;
        };
        /**
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.blur = /**
         * @return {?}
         */
        function () {
            this.toggleDropdown = false;
        };
        /**
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.focus = /**
         * @return {?}
         */
        function () {
            /* istanbul ignore else */
            if (!this.disabled) {
                this.toggleSelectDropdown();
            }
        };
        /**
         * click handler on documnent to hide the open dropdown if clicked outside
         */
        /**
         * click handler on documnent to hide the open dropdown if clicked outside
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.clickOutsideComponent = /**
         * click handler on documnent to hide the open dropdown if clicked outside
         * @return {?}
         */
        function () {
            /* istanbul ignore else */
            if (!this.clickedInside) {
                this.toggleDropdown = false;
                this.resetArrowKeyActiveElement();
                // clear searh on close
                this.searchText = null;
                this.close.emit();
            }
            this.clickedInside = false;
        };
        /**
         * click handler on documnent to hide the open dropdown if clicked outside
         */
        /**
         * click handler on documnent to hide the open dropdown if clicked outside
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.KeyPressOutsideComponent = /**
         * click handler on documnent to hide the open dropdown if clicked outside
         * @return {?}
         */
        function () {
            /* istanbul ignore else */
            if (!this.insideKeyPress) {
                this.toggleDropdown = false;
                this.resetArrowKeyActiveElement();
            }
            this.insideKeyPress = false;
        };
        /**
         * Event handler for key up and down event and enter press for selecting element
         */
        /**
         * Event handler for key up and down event and enter press for selecting element
         * @param {?} $event
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.handleKeyboardEvent = /**
         * Event handler for key up and down event and enter press for selecting element
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            this.insideKeyPress = true;
            /* istanbul ignore else */
            if ($event.keyCode === 27 || this.disabled) {
                this.toggleDropdown = false;
                this.insideKeyPress = false;
                return;
            }
            /** @type {?} */
            var avaOpts = this.availableOptions.toArray();
            /* istanbul ignore else */
            if ($event.keyCode !== 9 && avaOpts.length === 0 && !this.toggleDropdown) {
                this.toggleDropdown = true;
            }
            // Arrow Down
            /* istanbul ignore else */
            if ($event.keyCode === 40 && avaOpts.length > 0) {
                this.onArrowKeyDown();
                /* istanbul ignore else */
                if (this.focusedItemIndex >= avaOpts.length) {
                    this.focusedItemIndex = 0;
                }
                avaOpts[this.focusedItemIndex].nativeElement.focus();
                $event.preventDefault();
            }
            // Arrow Up
            /* istanbul ignore else */
            if ($event.keyCode === 38 && avaOpts.length) {
                this.onArrowKeyUp();
                /* istanbul ignore else */
                if (this.focusedItemIndex >= avaOpts.length) {
                    this.focusedItemIndex = avaOpts.length - 1;
                }
                avaOpts[this.focusedItemIndex].nativeElement.focus();
                $event.preventDefault();
            }
            // Enter
            /* istanbul ignore else */
            if ($event.keyCode === 13 && this.focusedItemIndex !== null) {
                /** @type {?} */
                var filteredItems = new FilterByPipe().transform(this.availableItems, this.searchText, this.config.searchOnKey);
                this.selectItem(filteredItems[this.focusedItemIndex], this.availableItems.indexOf(filteredItems[this.focusedItemIndex]));
                return false;
            }
        };
        /**
         * Component onInit
         */
        /**
         * Component onInit
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.ngOnInit = /**
         * Component onInit
         * @return {?}
         */
        function () {
            /* istanbul ignore else */
            if (typeof this.options !== 'undefined' && Array.isArray(this.options)) {
                this.availableItems = __spread(this.options.sort(this.config.customComparator));
                this.initDropdownValuesAndOptions();
            }
        };
        /**
         * after view init to subscribe to available option changes
         */
        /**
         * after view init to subscribe to available option changes
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.ngAfterViewInit = /**
         * after view init to subscribe to available option changes
         * @return {?}
         */
        function () {
            this.availableOptions.changes.subscribe(this.setNotFoundState.bind(this));
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @param {?} value
         * @param {?=} internal
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.writeValue = /**
         * @param {?} value
         * @param {?=} internal
         * @return {?}
         */
        function (value, internal) {
            if (value) {
                if (Array.isArray(value)) {
                    if (this.multiple) {
                        this.value = value;
                    }
                    else if (value.length > 0) {
                        this.value = value[0];
                    }
                }
                else {
                    this.value = value;
                }
                /* istanbul ignore else */
                if (this.selectedItems.length === 0) {
                    if (Array.isArray(value)) {
                        this.selectedItems = value;
                    }
                    else {
                        this.selectedItems.push(value);
                    }
                    this.initDropdownValuesAndOptions();
                }
            }
            else {
                this.value = [];
                /* istanbul ignore else */
                if (!internal) {
                    this.reset();
                }
            }
            /* istanbul ignore else */
            if (!internal) {
                this.reset();
            }
        };
        /**
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.reset = /**
         * @return {?}
         */
        function () {
            this.selectedItems = [];
            this.availableItems = __spread(this.options.sort(this.config.customComparator));
            this.initDropdownValuesAndOptions();
        };
        /**
         * function sets whether to show items not found text or not
         */
        /**
         * function sets whether to show items not found text or not
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.setNotFoundState = /**
         * function sets whether to show items not found text or not
         * @return {?}
         */
        function () {
            if (this.availableOptions.length === 0) {
                this.showNotFound = true;
            }
            else {
                this.showNotFound = false;
            }
            this.cdref.detectChanges();
        };
        /**
         * Component onchage i.e when any of the input properties change
         */
        /**
         * Component onchage i.e when any of the input properties change
         * @param {?} changes
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.ngOnChanges = /**
         * Component onchage i.e when any of the input properties change
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            this.selectedItems = [];
            // this.searchText = null;
            this.options = this.options || [];
            /* istanbul ignore else */
            if (changes.options) {
                this.availableItems = __spread(this.options.sort(this.config.customComparator));
            }
            /* istanbul ignore else */
            if (changes.value) {
                /* istanbul ignore else */
                if (JSON.stringify(changes.value.currentValue) === JSON.stringify([]) ||
                    changes.value.currentValue === '' ||
                    changes.value.currentValue === null) {
                    this.availableItems = __spread(this.options.sort(this.config.customComparator));
                }
            }
            this.initDropdownValuesAndOptions();
        };
        /**
         * Deselct a selected items
         * @param item:  item to be deselected
         * @param index:  index of the item
         */
        /**
         * Deselct a selected items
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.deselectItem = /**
         * Deselct a selected items
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        function (item, index) {
            var _this = this;
            this.selectedItems.forEach((/**
             * @param {?} element
             * @param {?} i
             * @return {?}
             */
            function (element, i) {
                /* istanbul ignore else */
                if (item === element) {
                    _this.selectedItems.splice(i, 1);
                }
            }));
            /** @type {?} */
            var sortedItems = __spread(this.availableItems);
            /* istanbul ignore else */
            if (!this.availableItems.includes(item)) {
                this.availableItems.push(item);
                sortedItems = this.availableItems.sort(this.config.customComparator);
            }
            this.selectedItems = __spread(this.selectedItems);
            this.availableItems = __spread(sortedItems);
            /* istanbul ignore else */
            if (!Array.isArray(this.value)) {
                this.value = [];
            }
            this.valueChanged();
            this.resetArrowKeyActiveElement();
        };
        /**
         * Select an item
         * @param item:  item to be selected
         * @param index:  index of the item
         */
        /**
         * Select an item
         * @param {?} item
         * @param {?=} index
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.selectItem = /**
         * Select an item
         * @param {?} item
         * @param {?=} index
         * @return {?}
         */
        function (item, index) {
            var _this = this;
            /* istanbul ignore else */
            if (!this.multiple) {
                /* istanbul ignore else */
                if (this.selectedItems.length > 0) {
                    this.availableItems.push(this.selectedItems[0]);
                }
                this.selectedItems = [];
                this.toggleDropdown = false;
            }
            this.availableItems.forEach((/**
             * @param {?} element
             * @param {?} i
             * @return {?}
             */
            function (element, i) {
                /* istanbul ignore else */
                if (item === element) {
                    _this.selectedItems.push(item);
                    _this.availableItems.splice(i, 1);
                }
            }));
            /* istanbul ignore else */
            if (this.config.clearOnSelection) {
                this.searchText = null;
            }
            this.selectedItems = __spread(this.selectedItems);
            this.availableItems = __spread(this.availableItems);
            this.selectedItems.sort(this.config.customComparator);
            this.availableItems.sort(this.config.customComparator);
            // this.searchText = null;
            this.valueChanged();
            this.resetArrowKeyActiveElement();
        };
        /**
         * When selected items changes trigger the chaange back to parent
         */
        /**
         * When selected items changes trigger the chaange back to parent
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.valueChanged = /**
         * When selected items changes trigger the chaange back to parent
         * @return {?}
         */
        function () {
            this.writeValue(this.selectedItems, true);
            // this.valueChange.emit(this.value);
            this.change.emit({ value: this.value });
            this.setSelectedDisplayText();
        };
        /**
         * Toggle the dropdownlist on/off
         */
        /**
         * Toggle the dropdownlist on/off
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.toggleSelectDropdown = /**
         * Toggle the dropdownlist on/off
         * @return {?}
         */
        function () {
            this.toggleDropdown = !this.toggleDropdown;
            if (this.toggleDropdown) {
                this.open.emit();
            }
            else {
                this.searchText = null;
                this.close.emit();
            }
            this.resetArrowKeyActiveElement();
        };
        /**
         * The change handler for search text
         */
        /**
         * The change handler for search text
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.searchTextChanged = /**
         * The change handler for search text
         * @return {?}
         */
        function () {
            this.searchChange.emit(this.searchText);
        };
        /**
         * @param {?} $event
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.changeSearchText = /**
         * @param {?} $event
         * @return {?}
         */
        function ($event) {
            $event.stopPropagation();
        };
        /**
         * initialize the config and other properties
         */
        /**
         * initialize the config and other properties
         * @private
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.initDropdownValuesAndOptions = /**
         * initialize the config and other properties
         * @private
         * @return {?}
         */
        function () {
            var e_1, _a;
            var _this = this;
            /** @type {?} */
            var config = {
                displayKey: 'description',
                height: 'auto',
                search: false,
                placeholder: 'Select',
                searchPlaceholder: 'Search...',
                limitTo: 0,
                customComparator: undefined,
                noResultsFound: 'No results found!',
                moreText: 'more',
                searchOnKey: null,
                clearOnSelection: false,
                inputDirection: 'ltr',
            };
            /* istanbul ignore else */
            if (this.config === 'undefined' || Object.keys(this.config).length === 0) {
                this.config = __assign({}, config);
            }
            try {
                for (var _b = __values(Object.keys(config)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    this.config[key] = this.config[key] ? this.config[key] : config[key];
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.config = __assign({}, this.config);
            // Adding placeholder in config as default param
            this.selectedDisplayText = this.config['placeholder'];
            /* istanbul ignore else */
            if (this.value !== '' && typeof this.value !== 'undefined') {
                if (Array.isArray(this.value)) {
                    this.selectedItems = this.value;
                }
                else if (this.value !== '' && this.value !== null) {
                    this.selectedItems[0] = this.value;
                }
                else {
                    this.selectedItems = [];
                    this.value = [];
                }
                this.selectedItems.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    /** @type {?} */
                    var ind = _this.availableItems.findIndex((/**
                     * @param {?} aItem
                     * @return {?}
                     */
                    function (aItem) { return JSON.stringify(item) === JSON.stringify(aItem); }));
                    if (ind !== -1) {
                        _this.availableItems.splice(ind, 1);
                    }
                }));
            }
            this.setSelectedDisplayText();
        };
        /**
         * set the text to be displayed
         */
        /**
         * set the text to be displayed
         * @private
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.setSelectedDisplayText = /**
         * set the text to be displayed
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var text = this.selectedItems[0];
            /* istanbul ignore else */
            if (typeof this.selectedItems[0] === 'object') {
                text = this.config.displayFn
                    ? this.config.displayFn(this.selectedItems[0])
                    : this.selectedItems[0][this.config.displayKey];
            }
            if (this.multiple && this.selectedItems.length > 0) {
                this.selectedDisplayText =
                    this.selectedItems.length === 1
                        ? text
                        : text +
                            (" + " + (this.selectedItems.length - 1) + " " + this.config.moreText);
            }
            else {
                this.selectedDisplayText =
                    this.selectedItems.length === 0 ? this.config.placeholder : text;
            }
        };
        /**
         * Event handler for arrow key up event thats focuses on a item
         */
        /**
         * Event handler for arrow key up event thats focuses on a item
         * @private
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.onArrowKeyUp = /**
         * Event handler for arrow key up event thats focuses on a item
         * @private
         * @return {?}
         */
        function () {
            /* istanbul ignore else */
            if (this.focusedItemIndex === 0) {
                this.focusedItemIndex = this.availableItems.length - 1;
                return;
            }
            /* istanbul ignore else */
            if (this.onArrowKey()) {
                this.focusedItemIndex--;
            }
        };
        /**
         * Event handler for arrow key down event thats focuses on a item
         */
        /**
         * Event handler for arrow key down event thats focuses on a item
         * @private
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.onArrowKeyDown = /**
         * Event handler for arrow key down event thats focuses on a item
         * @private
         * @return {?}
         */
        function () {
            /* istanbul ignore else */
            if (this.focusedItemIndex === this.availableItems.length - 1) {
                this.focusedItemIndex = 0;
                return;
            }
            /* istanbul ignore else */
            if (this.onArrowKey()) {
                this.focusedItemIndex++;
            }
        };
        /**
         * @private
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.onArrowKey = /**
         * @private
         * @return {?}
         */
        function () {
            /* istanbul ignore else */
            if (this.focusedItemIndex === null) {
                this.focusedItemIndex = 0;
                return false;
            }
            return true;
        };
        /**
         * will reset the element that is marked active using arrow keys
         */
        /**
         * will reset the element that is marked active using arrow keys
         * @private
         * @return {?}
         */
        NgxSelectDropdownComponent.prototype.resetArrowKeyActiveElement = /**
         * will reset the element that is marked active using arrow keys
         * @private
         * @return {?}
         */
        function () {
            this.focusedItemIndex = null;
        };
        NgxSelectDropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-select-dropdown',
                        template: "<div class=\"ngx-dropdown-container\" tabindex=\"0\">\n    <button type=\"button\" tabindex=\"-1\" class=\"ngx-dropdown-button\" [ngClass]=\"{ 'ngx-disabled': disabled }\"\n        [disabled]=\"disabled\" (click)=\"toggleSelectDropdown()\">\n        <span class=\"display-text\">{{ selectedDisplayText }} </span>\n        <span class=\"nsdicon-angle-down\"></span>\n    </button>\n    <div class=\"ngx-dropdown-list-container\" *ngIf=\"toggleDropdown\" [style.maxHeight]=\"config.height\">\n        <div class=\"search-container\" *ngIf=\"config.search\">\n            <input (change)=\"changeSearchText($event)\" [style.direction]=\"config.inputDirection\" name=\"search-text\"\n                (input)=\"searchTextChanged()\" [(ngModel)]=\"searchText\" tabindex=\"-1\" autocomplete=\"off\" />\n            <label [ngClass]=\"{ active: searchText }\">\n                <span class=\"nsdicon-search\"></span>\n                {{ config.searchPlaceholder }}</label>\n        </div>\n        <ul class=\"selected-items\">\n            <li tabindex=\"-1\" *ngFor=\"let selected of selectedItems; let i = index\" (click)=\"deselectItem(selected, i)\">\n                <span class=\"nsdicon-close\">x</span>\n                <span>\n                    {{\n                    config.displayFn\n                    ? config.displayFn(selected)\n                    : selected[config.displayKey] || selected\n                    }}\n                </span>\n            </li>\n        </ul>\n        <hr *ngIf=\"selectedItems.length > 0 && availableItems.length > 0\" />\n        <ul class=\"available-items\">\n            <li #availableOption *ngFor=\"\n            let item of availableItems\n              | filterBy: searchText:config.searchOnKey\n              | limitTo: config.limitTo;\n            let i = index\n          \" tabindex=\"-1\" [ngClass]=\"{\n            active: focusedItemIndex == i && !item.disabled,\n            disabled: item.disabled\n          }\" (click)=\"selectItem(item, i)\">\n                {{\n                config.displayFn\n                ? config.displayFn(item)\n                : item[config.displayKey] || item\n                }}\n            </li>\n            <li *ngIf=\"showNotFound\">{{ config.noResultsFound }}</li>\n        </ul>\n    </div>\n</div>",
                        providers: [
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return NgxSelectDropdownComponent; })),
                                multi: true,
                            },
                        ],
                        styles: [".ngx-dropdown-container{width:100%;position:relative}.ngx-dropdown-container button{display:inline-block;margin-bottom:0;font-weight:400;line-height:1.42857143;vertical-align:middle;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:1px solid #ccc;border-radius:4px;color:#333;background-color:#fff;white-space:nowrap;overflow-x:hidden;text-overflow:ellipsis;text-align:left}.ngx-dropdown-container button span{display:inline;vertical-align:middle}.ngx-dropdown-container button .nsdicon-angle-down{right:5px;position:relative;float:right}.ngx-dropdown-container button .nsdicon-angle-down::before{border-style:solid;border-width:.1em .1em 0 0;content:\"\";display:inline-block;height:10px;position:relative;vertical-align:text-top;width:10px;top:0;transform:rotate(135deg)}.ngx-dropdown-container .ngx-dropdown-button{width:100%;min-height:30px;padding:5px 10px;background-color:#fff}.ngx-dropdown-container .ngx-dropdown-button .display-text{display:inline-block;width:calc(100% - 20px)}.ngx-dropdown-container .ngx-dropdown-list-container{box-sizing:border-box;border:1px solid rgba(0,0,0,.15);border-radius:4px;padding-left:10px;padding-right:10px;z-index:999999999;width:100%;background:#fff;position:absolute;box-shadow:5px 5px 5px 0 rgba(0,0,0,.21);overflow-y:auto}.ngx-dropdown-container .ngx-dropdown-list-container .search-container{position:relative;padding-top:10px;margin-top:5px}.ngx-dropdown-container .ngx-dropdown-list-container .search-container input{background-color:transparent;border:none;border-bottom:1px solid #9e9e9e;border-radius:0;outline:0;height:2rem;width:100%;font-size:13px;margin:0;padding:0;box-shadow:none;box-sizing:content-box;transition:.3s}.ngx-dropdown-container .ngx-dropdown-list-container .search-container input:focus{border-bottom:1px solid #26a69a}.ngx-dropdown-container .ngx-dropdown-list-container .search-container input:focus+label{transform:translateY(-2px) scale(.8);transform-origin:0 0}.ngx-dropdown-container .ngx-dropdown-list-container .search-container label{color:#9e9e9e;position:absolute;top:0;left:0;height:100%;font-size:1rem;cursor:text;transition:transform .2s ease-out;transform-origin:0 100%;text-align:initial;transform:translateY(12px);pointer-events:none}.ngx-dropdown-container .ngx-dropdown-list-container .search-container label.active{transform:translateY(-2px) scale(.8);transform-origin:0 0}.ngx-dropdown-container .ngx-dropdown-list-container ul{margin-top:1rem;margin-bottom:1rem;list-style-type:none;padding-left:0}.ngx-dropdown-container .ngx-dropdown-list-container ul.selected-items li{background-color:#337ab7;color:#fff;margin-bottom:2px}.ngx-dropdown-container .ngx-dropdown-list-container ul.selected-items li .nsdicon-close{font-weight:700;font-size:large}.ngx-dropdown-container .ngx-dropdown-list-container ul.available-items li.active{background-color:#337ab7;color:#ffff}.ngx-dropdown-container .ngx-dropdown-list-container ul li{font-size:inherit;cursor:pointer;display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:normal}.ngx-dropdown-container .ngx-disabled{pointer-events:none;background-color:#e9ecef;opacity:1;cursor:no-drop}"]
                    }] }
        ];
        /** @nocollapse */
        NgxSelectDropdownComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        NgxSelectDropdownComponent.propDecorators = {
            _value: [{ type: core.Input }],
            options: [{ type: core.Input }],
            config: [{ type: core.Input }],
            multiple: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            change: [{ type: core.Output }],
            searchChange: [{ type: core.Output }],
            open: [{ type: core.Output }],
            close: [{ type: core.Output }],
            availableOptions: [{ type: core.ViewChildren, args: ['availableOption',] }],
            clickInsideComponent: [{ type: core.HostListener, args: ['click',] }],
            blur: [{ type: core.HostListener, args: ['blur',] }],
            focus: [{ type: core.HostListener, args: ['focus',] }],
            clickOutsideComponent: [{ type: core.HostListener, args: ['document:click',] }],
            KeyPressOutsideComponent: [{ type: core.HostListener, args: ['document:keydown',] }],
            handleKeyboardEvent: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return NgxSelectDropdownComponent;
    }());
    if (false) {
        /**
         * value of the dropdown
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype._value;
        /**
         * Get the required inputs
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.options;
        /**
         * configuration options
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.config;
        /**
         * Whether multiple selection or single selection allowed
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.multiple;
        /**
         * Value
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.disabled;
        /**
         * change event when value changes to provide user to handle things in change event
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.change;
        /**
         * The search text change event emitter emitted when user type in the search input
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.searchChange;
        /**
         * Event emitted when dropdown is open.
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.open;
        /**
         * Event emitted when dropdown is open.
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.close;
        /**
         * Toogle the dropdown list
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.toggleDropdown;
        /**
         * Available items for selection
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.availableItems;
        /**
         * Selected Items
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.selectedItems;
        /**
         * Selection text to be Displayed
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.selectedDisplayText;
        /**
         * Search text
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.searchText;
        /**
         * variable to track if clicked inside or outside of component
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.clickedInside;
        /**
         * variable to track keypress event inside and outsid of component
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.insideKeyPress;
        /**
         * variable to track the focused item whenuser uses arrow keys to select item
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.focusedItemIndex;
        /**
         * element to show not found text when not itmes match the search
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.showNotFound;
        /**
         * Hold the reference to available items in the list to focus on the item when scrolling
         * @type {?}
         */
        NgxSelectDropdownComponent.prototype.availableOptions;
        /** @type {?} */
        NgxSelectDropdownComponent.prototype.onChange;
        /** @type {?} */
        NgxSelectDropdownComponent.prototype.onTouched;
        /**
         * @type {?}
         * @private
         */
        NgxSelectDropdownComponent.prototype.cdref;
        /** @type {?} */
        NgxSelectDropdownComponent.prototype._elementRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/pipes/limit-to.pipe.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LimitToPipe = /** @class */ (function () {
        function LimitToPipe() {
        }
        /**
         * @param {?} array
         * @param {?} itemsCount
         * @param {?=} startIndex
         * @return {?}
         */
        LimitToPipe.prototype.transform = /**
         * @param {?} array
         * @param {?} itemsCount
         * @param {?=} startIndex
         * @return {?}
         */
        function (array, itemsCount, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            if (!Array.isArray(array) || itemsCount === 0) {
                return array;
            }
            return array.slice(startIndex, startIndex + itemsCount);
        };
        LimitToPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'limitTo'
                    },] }
        ];
        return LimitToPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/ngx-select-dropdown.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SelectDropDownModule = /** @class */ (function () {
        function SelectDropDownModule() {
        }
        SelectDropDownModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [NgxSelectDropdownComponent, FilterByPipe, LimitToPipe],
                        imports: [common.CommonModule, forms.FormsModule],
                        exports: [NgxSelectDropdownComponent, FilterByPipe, LimitToPipe]
                    },] }
        ];
        return SelectDropDownModule;
    }());

    exports.FilterByPipe = FilterByPipe;
    exports.LimitToPipe = LimitToPipe;
    exports.NgxSelectDropdownComponent = NgxSelectDropdownComponent;
    exports.SelectDropDownModule = SelectDropDownModule;
    exports.SelectDropDownService = SelectDropDownService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-select-dropdown.umd.js.map
